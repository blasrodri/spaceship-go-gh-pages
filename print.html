<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Spaceship Go</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">2.</strong> Preface</a></li><li class="chapter-item expanded "><a href="notes-about-godocs.html"><strong aria-hidden="true">3.</strong> Notes About Go Docs</a></li><li class="chapter-item expanded "><a href="built-in.html"><strong aria-hidden="true">4.</strong> Built in</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="built-in-constants.html"><strong aria-hidden="true">4.1.</strong> Constants</a></li><li class="chapter-item expanded "><a href="built-in-make-and-new.html"><strong aria-hidden="true">4.2.</strong> make and new</a></li><li class="chapter-item expanded "><a href="built-in-defer.html"><strong aria-hidden="true">4.3.</strong> defer</a></li><li class="chapter-item expanded "><a href="built-in-panic.html"><strong aria-hidden="true">4.4.</strong> panic</a></li><li class="chapter-item expanded "><a href="built-in-recover.html"><strong aria-hidden="true">4.5.</strong> recover</a></li></ol></li><li class="chapter-item expanded "><a href="bytes-intro.html"><strong aria-hidden="true">5.</strong> Bytes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bytes-compare.html"><strong aria-hidden="true">5.1.</strong> Compare</a></li><li class="chapter-item expanded "><a href="bytes-index.html"><strong aria-hidden="true">5.2.</strong> Index</a></li><li class="chapter-item expanded "><a href="bytes-buffers.html"><strong aria-hidden="true">5.3.</strong> Buffers</a></li></ol></li><li class="chapter-item expanded "><a href="context-intro.html"><strong aria-hidden="true">6.</strong> Context</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="context-details.html"><strong aria-hidden="true">6.1.</strong> In detail</a></li></ol></li><li class="chapter-item expanded "><a href="errors-intro.html"><strong aria-hidden="true">7.</strong> Errors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="errors-As-Is.html"><strong aria-hidden="true">7.1.</strong> As and Is</a></li><li class="chapter-item expanded "><a href="errors-unwrap.html"><strong aria-hidden="true">7.2.</strong> Unwrap</a></li><li class="chapter-item expanded "><a href="errors-great-again.html"><strong aria-hidden="true">7.3.</strong> Making error great again</a></li></ol></li><li class="chapter-item expanded "><a href="sync-intro.html"><strong aria-hidden="true">8.</strong> Sync</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sync-cond.html"><strong aria-hidden="true">8.1.</strong> Cond</a></li><li class="chapter-item expanded "><a href="sync-mutex.html"><strong aria-hidden="true">8.2.</strong> Mutex</a></li><li class="chapter-item expanded "><a href="sync-do.html"><strong aria-hidden="true">8.3.</strong> Do</a></li><li class="chapter-item expanded "><a href="sync-pool.html"><strong aria-hidden="true">8.4.</strong> Pool</a></li><li class="chapter-item expanded "><a href="sync-waitgroup.html"><strong aria-hidden="true">8.5.</strong> WaitGroup</a></li></ol></li><li class="chapter-item expanded "><a href="io-intro.html"><strong aria-hidden="true">9.</strong> IO</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="io-reader-and-writer.html"><strong aria-hidden="true">9.1.</strong> Reader and Writer</a></li><li class="chapter-item expanded "><a href="io-pipe-in-depth.html"><strong aria-hidden="true">9.2.</strong> Pipe in depth</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Spaceship Go</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="./controllers_brief.svg" alt="" />
<img src="./img/cover.svg"></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>Welcome, traveler! This is a set of notes of my journey into part of Go's
standard library, comprised into a book. I hope you enjoy it!
Each chapter provides a dive into some packages. I will provide a brief
introduction of what is the main purpose of the package, and some examples to
help to understand. In some cases, I will add some references to external
content that work either as a complementary view to the topic, or even to extend
the coverage of the subject.</p>
<h2 id="who-is-this-book-for"><a class="header" href="#who-is-this-book-for">Who is this book for?</a></h2>
<p>Ideally you are a software developer, or someone with great interest in how to write
code. Having an understanding on the syntax and certain command of the Go programming
language will certainly help. However, I will try to keep the explanations as
simple as possible in order to be able to reach to a larger audience. And
hopefully, this will still be found interesting for those looking for getting
a deeper understanding of what tools the language and its runtime has to offer.</p>
<h2 id="feedback-and-comments"><a class="header" href="#feedback-and-comments">Feedback and comments</a></h2>
<p>This book is built entirely using markdown. And it's also hosted publicly on Github.
For comments, issues, or any kind of feedback, please use the
<a href="https://github.com/blasrodri/spaceship-go">Spaceship Go</a> repository. PR's are more
than wlecome, of any type!</p>
<h2 id="special-thanks"><a class="header" href="#special-thanks">Special thanks</a></h2>
<p>Most of the book is just my interpretation of the Go's standard library. Besides this, I've
found that the Go Blog is an extremely useful resource. Big thanks especially
to Andrew Gerrand, for all the great contributions he has in that space.</p>
<p>There is also a Youtube channel called <strong>just for func</strong>, which I also highly
recommend. It was particularly useful to prepare the groundwork for the <code>Context</code>
chapter. Thanks to its creator, Francesc Campoy.</p>
<p>The cover of the book is based on original work from <a href="https://github.com/egonelbre/gophers">egonelbre gophers repo</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="notes-about-go-docs"><a class="header" href="#notes-about-go-docs">Notes about Go docs</a></h1>
<p>When visiting any of the packages in <a href="https://golang.org/pkg/">Go Std Library</a>,
there is a certain pattern that is being kept through. It helps to dissect it,
so that we know what to expect from these docs, and also where to get extra
information. First, there is an <strong>Overview</strong>, which is a simple paragraph that
explains the scope of the package. It essentially tells the reader what to
expect from the package in question. Additionally, in some cases, it can make
some references to other packages when this helps to understand some design
choices. This can, for example, happen when the API of two packages is very
similar (i.e. bytes and strings).</p>
<p>The <strong>Index</strong> lists all the contents of the package. It outlines all the constants,
variables, functions, structs, methods, and interfaces exported by the package.
It's important to note that everything that is being listed in the docs is
public elements. That means, that the author of the package has deliberately
chosen to let the user of the API call. But there are other elements, that are
not public. And these help to build functionality, but the author has chosen not
to expose them out of the package. It is sometimes useful to go through the
private items of the package. This can help to get some understanding of the
design choices and trade-offs of some implementation. These private blocks are
found directly in the source code of the package, which is found at the bottom
of the index and examples, with the title of <strong>package files</strong>.</p>
<h2 id="go-specification"><a class="header" href="#go-specification">Go Specification</a></h2>
<p>It's important to note that, while the scope of this book is the Standard Library,
there is a lot of useful information in the <a href="https://golang.org/ref/spec">Go Spec</a>.
This is a resource that needs to be considered and reviewed almost every time,
when in doubt of how internal things work in the language.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="built-in"><a class="header" href="#built-in">Built in</a></h1>
<blockquote>
<p>Package builtin provides documentation for Go's predeclared identifiers.
The items documented here are not actually in package builtin (...)</p>
<p><em>Built in package overview</em></p>
</blockquote>
<p>Even though none of the items are defined in the built in package, it serves as a
compilation of highly used items that every Go developer needs to be aware of.
The goal of this chapter is to cover some of these elements, with special focus
on how they are implemented.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Booleans true and false are defined here. And in a very smart and concise way:</p>
<pre><code class="language-go">const (
    true = 0 == 0 // this is always true!
    false = 0 != 0 // this is always false!
)
</code></pre>
<p>Iota (view https://github.com/golang/go/wiki/Iota and https://golang.org/ref/spec#Iota)
represents successive untyped integer constants.</p>
<pre><code class="language-go">const iota = 0 // Untyped int.
</code></pre>
<p>These two examples, describe how iota can be useful:</p>
<pre><code class="language-go">const (
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const (
	a = 1 &lt;&lt; iota  // a == 1  (iota == 0)
	b = 1 &lt;&lt; iota  // b == 2  (iota == 1)
	c = 3          // c == 3  (iota == 2, unused)
	d = 1 &lt;&lt; iota  // d == 8  (iota == 3)
)
</code></pre>
<p>Note: The <code>&lt;&lt;</code> is a left shift operand, which shift lefts the operand by an integer
(in this case <code>iota</code> value). So, for instance <code>1 &lt;&lt; 2</code> equals <code>1 * 2 * 2</code>.</p>
<p><code>nil</code> is a widely used variable. It is defined as:</p>
<pre><code class="language-go">var nil Type
</code></pre>
<p>It represents the zero value of a type, within these clases: slices, pointer,
map, func, interface, or channel.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="make-and-new"><a class="header" href="#make-and-new">make and new</a></h1>
<h2 id="make"><a class="header" href="#make">make</a></h2>
<p><code>make</code> is a very singular function. Its purpose is to allocate and initialize
an object of type slice, map, or chan (only). The output depends on the type
it's operating upon. You can see the differences, depending upon the type in the
excerpt below:</p>
<pre><code class="language-go">// from src/go/cmd/compile/internal/gc/builtin/runtime.go
func makemap64(mapType *byte, hint int64, mapbuf *any) (hmap map[any]any)
func makemap(mapType *byte, hint int, mapbuf *any) (hmap map[any]any)
func makemap_small() (hmap map[any]any)
func makechan64(chanType *byte, size int64) (hchan chan any)
func makechan(chanType *byte, size int) (hchan chan any)
func makeslice(typ *byte, len int, cap int) unsafe.Pointer
func makeslice64(typ *byte, len int64, cap int64) unsafe.Pointer
func makeslicecopy(typ *byte, tolen int, fromlen int, from unsafe.Pointer) unsafe.Pointer
</code></pre>
<h2 id="new"><a class="header" href="#new">new</a></h2>
<p>It can be thought as a <code>make</code> alternative, but with a size equal to zero and
always initializing the value to its zero value.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="defer"><a class="header" href="#defer">defer</a></h2>
<p>This function is not defined in the built-in package. But since it is used in
the example for <code>recover</code> I wanted to mention it.</p>
<p><code>defer</code> is used to ensure that a function will be executed right before the 
funcation that calls it terminates. As <a href="https://gobyexample.com/defer">Go By example</a>
mentions, other languages provide the construct <em>finally</em> in some contexts.</p>
<p>The syntax is simple:</p>
<pre><code class="language-go">defer func() { // ... 
}()
</code></pre>
<p>Or directly</p>
<pre><code class="language-go">defer closeFile(f)
</code></pre>
<p><code>defer</code> takes a closure as argument. Which means that it is possible to include a wide
range of elements inside it.</p>
<p>As noted in the <a href="./built-in-recover.html">recover</a> section, if we call <code>defer</code> multiple times, the order in which
these functions will be executed is <strong>last in, first out</strong>. So, for instance:</p>
<pre><code class="language-go">import (
    &quot;fmt&quot;
)
func main() {
    fmt.Println(&quot;Let's count backwards:&quot;)
    defer func() {
        fmt.Println(1)
    }()
    defer func() {
        fmt.Println(2)
    }()
    defer func() {
        fmt.Println(3)
    }()
}
</code></pre>
<p>This will output</p>
<pre><code>Let's count backwards:
3
2
1
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="panic"><a class="header" href="#panic">panic</a></h2>
<p>It's a function that stops the normal execution of the goroutine. All the
deferred functions are still being called, and once they complete this goroutine
returns to the caller. To the caller, the panic on the callee triggers a
termination on itself. This is a recursive mechanism that can eventually terminate
in the program exiting with a non-zero code. However, it's possbile to control it
using recover. <code>panic</code> has different variants, and some are implemented in assembly,
while some other purely in Go.</p>
<pre><code class="language-go">// Some are implemented in go

func panicshift()
func panicdivide()
</code></pre>
<pre><code class="language-go">// Some others are implemented in assembly

func panicIndex(x, y int)
func panicIndexU(x uint, y int)
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="recover"><a class="header" href="#recover">recover</a></h2>
<p>Recover is a built-in function allows a program to manage behavior of a panicking
goroutine. It is useful only <strong>inside a deferred function</strong>. It stops the panicking
sequence by restoring normal execution and retrieves the error value passed to the
call of panic. If recover is called outside the deferred function it will not stop
a panicking sequence. In this case, or when the goroutine is not panicking, or if
the argument supplied to panic was nil, recover returns nil. Thus the return value
from recover reports whether the goroutine is panicking.</p>
<p>An example (https://blog.golang.org/defer-panic-and-recover) of the mechanisms of
panic and defer:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    f()
    fmt.Println(&quot;Returned normally from f.&quot;)
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println(&quot;Recovered in f&quot;, r)
        }
    }()
    fmt.Println(&quot;Calling g.&quot;)
    g(0)
    fmt.Println(&quot;Returned normally from g.&quot;)
}

func g(i int) {
    if i &gt; 3 {
        fmt.Println(&quot;Panicking!&quot;)
        panic(fmt.Sprintf(&quot;%v&quot;, i))
    }
    defer fmt.Println(&quot;Defer in g&quot;, i)
    fmt.Println(&quot;Printing in g&quot;, i)
    g(i + 1)
}

// outputs
// Calling g.
// Printing in g 0
// Printing in g 1
// Printing in g 2
// Printing in g 3
// Panicking!
// Defer in g 3
// Defer in g 2
// Defer in g 1
// Defer in g 0
// Recovered in f 4
// Returned normally from f.
</code></pre>
<p>Note that the call to referred functions goes in the opposite direction.
This is because the defer statement places the goroutine in the goroutine stack.
And thus, they get popped in LIFO order.</p>
<p>The same example, but without calling <code>recover</code> inside a defer is presented below:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    f()
    fmt.Println(&quot;Returned normally from f.&quot;)
}

func f() {
//    defer func() {
//        if r := recover(); r != nil {
//            fmt.Println(&quot;Recovered in f&quot;, r)
//       }
//    }()
    fmt.Println(&quot;Calling g.&quot;)
    g(0)
    fmt.Println(&quot;Returned normally from g.&quot;)
}

func g(i int) {
    if i &gt; 3 {
        fmt.Println(&quot;Panicking!&quot;)
        panic(fmt.Sprintf(&quot;%v&quot;, i))
    }
    defer fmt.Println(&quot;Defer in g&quot;, i)
    fmt.Println(&quot;Printing in g&quot;, i)
    g(i + 1)
}

// outputs
// Calling g.
// Printing in g 0
// Printing in g 1
// Printing in g 2
// Printing in g 3
// Panicking!
// Defer in g 3
// Defer in g 2
// Defer in g 1
// Defer in g 0

// AND NOW, this is different!

// panic: 4
// panic PC=0x2a9cd8
// [stack trace omitted]
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="bytes"><a class="header" href="#bytes">Bytes</a></h1>
<p>Bytes are program's building blocks.</p>
<p>In Go, a byte is a type alias of <code>uint8</code>, and thus it is defined as:</p>
<pre><code class="language-go">type byte = uint8
</code></pre>
<p>And thus, when talking about <strong>bytes</strong>, we mean a slice of <code>byte</code>, namely: <code>[]byte</code>.</p>
<h2 id="why-and-when-use-bytes"><a class="header" href="#why-and-when-use-bytes">Why and when use bytes?</a></h2>
<p>Bytes are pervasive, especially when working in systems programming. If you want
to work on an application related to networking, operating systems, databases,
you will likely end up working with bytes. And that is why it's very important
to understand what tools are available off the self.</p>
<p>In the following sections, we will address some operations Go allows us to
perform on bytes.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="compare"><a class="header" href="#compare">Compare</a></h2>
<p>First, we can compare two bytes. That is, having a function that tells us whether
these two bytes are the same or not.</p>
<pre><code class="language-go">func Compare(a, b []byte) int
</code></pre>
<p>The function Compare does this for us. It checks whether two <strong>byte slices</strong> are
the same, and returns the result as an integer. The function performs a
<a href="https://en.wikipedia.org/wiki/Lexicographical_order">lexicographic comparison</a>
and returns 0 if they are the same, -1 if a &lt; b and +1 if a &gt; b.</p>
<p>It's interesting to note how this function is implemented. Diving into Go's source code
we can see the following:</p>
<pre><code class="language-go">func Compare(a, b []byte) int {

	return bytealg.Compare(a, b)

}
</code></pre>
<p>Something as <em>simple</em> as just comparing bytes, involves going down to assembly language.
The function Compare calls the function Compare in the package <code>bytealg</code>, which defines 
<code>Compare</code> like this:</p>
<pre><code class="language-go">//go:noescape

func Compare(a, b []byte) int
</code></pre>
<p>The directive <code>//go:noespace</code> tells the compiler that the values passed to the function
must be stored in the stack. And addtionally that the function implementation is not written
in Go. This means that the byte comparison function is implemented in a lower laguage, like
assembly.</p>
<p>Check <a href="https://golang.org/cmd/compile/#hdr-Compiler_Directives">Compiler directives</a> if you
want to get more details in this topic.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="index"><a class="header" href="#index">Index</a></h1>
<p>Let's say we have some bytes, represented as a slice of byte, which in Go lingo means
<code>[]byte</code>. If we want to verify whether these bytes contain a certain subset of bytes,
and we're particularly interested in knowing where in the slice they are located
we can use the function <code>Index</code>, provided in the package <strong>bytes</strong>.</p>
<pre><code class="language-go">func Index(s, sep []byte) int
</code></pre>
<p>The way it is implemented is as follows:</p>
<ul>
<li>If the lenght of the separator is 0, then it returns 0. Nothing more to do</li>
<li>If it is 1, it calls another function called IndexByte to do the work.
This is also an assembly function. One of its variants can be found <a href="https://golang.org/src/internal/bytealg/indexbyte_amd64.s">here</a></li>
<li>If the sizes between sep and s match, then it checks whether they are equal or not. For that, it calls Equal, which we have already mentioned.</li>
<li>If the separator length is bigger than one, then it's no longer a byte. It then goes to a more complex logic involving <code>bytealg.Index</code>.</li>
</ul>
<p>Besides the full implementation, sometimes it's usefule to follow how things work under the hood.
And in such a low level package, we can find the need of working with assembly and targetting
the different architectures. Check <a href="https://golang.org/src/internal/bytealg/">bytealg package</a> for an overview.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="working-with-buffers"><a class="header" href="#working-with-buffers">Working with buffers</a></h2>
<p>Sometimes our program needs to manipulate bytes. And we might or might not now
what's the size of this stream of bytes coming. Or perhaps we need to work with
chunks... who knows!</p>
<p>Buffers can help you, when you find yourself in these waters. But wait. What's a buffer?
Think of it as a variable sized array of bytes. It's a data structure that can be
resized to accomodate more or less bytes. It lets you write (<code>WriteByte</code>) new bytes to it,
read bytes from it (<code>ReadByte</code>), remove some bytes (<code>Truncate</code>), remove all (<code>Reset</code>), etc.</p>
<p>To create a Buffer, we need to call either <code>NewBuffer</code> or <code>NewBufferString</code>.
The difference is in the input that they take. The former accepts a byte slice <code>[]byte</code>
while the latter expects a string.</p>
<p>For testing purposes let's say we create a buffer with some bytes:</p>
<pre><code class="language-go">// we call
b := bytes.NewBuffer([]byte(&quot;some bytes&quot;))
</code></pre>
<p>To get the slice back, the <code>Bytes</code> method that can be used:</p>
<pre><code class="language-go">b.Bytes() // [115 111 109 101 32 98 121 116 101 115]
</code></pre>
<p>We can read a fixed amount of bytes by using <code>Next(n int)</code>. It's important to note
that calling this method will actually <strong>read the bytes</strong>. And thus, the buffer
will have a new length of the previous one minus <code>n</code>. In case the buffer's length
was less than n, then the method will return the entire buffer.</p>
<p>Alternatively, buffers can grow, be truncated and reset. For that, we have:</p>
<pre><code class="language-go">func (b *Buffer) Grow(n int) // increases the buffer's capacity
func (b *Buffer) Truncate(n int)
func (*Buffer) Reset() // same as Truncate(0)
</code></pre>
<p><code>Truncate(n int)</code> will discard all the bytes from the buffer, except for the first n ones.
It does not shrink the capacity of the buffer. So this means that the buffer can still
accommodate the same amount of elements without having to perform a memory allocation.
If n &lt; 0 or n &gt; b.Len() then it panics.</p>
<p>If you want to shrink a buffer, Go does not offer a built in way of doing it.
An alternative of achieving it would be:</p>
<pre><code class="language-go">// https://stackoverflow.com/questions/16748330/does-go-have-no-real-way-to-shrink-a-slice-is-that-an-issue
b = append([]T(nil), b[:newSize]...)
</code></pre>
<p>It is possible to work with the <code>Reader</code> interface. But it won't be covered in this chapter.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="context"><a class="header" href="#context">Context</a></h1>
<p>Package context defines the Context type. A context can include deadlines,
cancellation signals, and other request-scoped values across API boundaries
and between processes. A key feature of this pattern is that it allows signals
to be propagated. So for instance, when a context is cancelled then all the
contexts derived from it are cancelled as well.</p>
<p>Context is a very singular pattern, that I have not seen implemented in the
standard libraries of other languages. And since it's widely adopted in different
projects, I thought it was worth covering it.</p>
<p>Go proposes an interface to work with <code>Context</code>, which is</p>
<blockquote>
<p>Programs that use Contexts should follow these rules to keep interfaces
consistent across packages and enable static analysis tools to check context propagation:</p>
<p>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it.
The Context should be the first parameter, typically named ctx:</p>
</blockquote>
<pre><code class="language-go">func DoSomething(ctx context.Context, arg Arg) error {
	// ... use ctx ...
}
</code></pre>
<p>Next, we describe some different functionalities offered by the package
and show alternatives of how it can be used. Much of it has been taken from
<a href="https://blog.golang.org/context">this blog post</a> by Sameer Ajmani.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="context-details"><a class="header" href="#context-details">Context details</a></h1>
<p>The <code>Context</code> carries a deadline, a cancellation signal, <code>Done</code> and other values
across processes and APIs. It is defined as an interface:</p>
<pre><code class="language-go">type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() &lt;-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
</code></pre>
<p>Note: these methods may be called by multiple goroutines simultaneously.</p>
<p>The package provides different types of contexts, with different <em>service levels</em>:</p>
<ul>
<li>emtpyCtx: it's one that is never cancelled, has no values and no deadline</li>
<li>canccelCtx: is one that can be cancelled. When cancelled, it also cancels all
its children that implement cancel.</li>
<li>valueCtx: carries a key-value pair. Delegates all other calls (such as cancel) to its
embedded context.</li>
<li>timerCtx: carries a timer and a deadline. It embeds <code>canccelCtx</code> to implement <code>Done</code> and <code>Err</code>.
<code>cancel</code> is implementing by stopping its timer and delegating the call to <code>cancelCtx</code></li>
</ul>
<p>It's important to note that as a user of the package, we only have access to these types through</p>
<pre><code class="language-go">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
</code></pre>
<h2 id="cancelfunc"><a class="header" href="#cancelfunc">CancelFunc</a></h2>
<pre><code class="language-go">type CancelFunc func()
</code></pre>
<p>When creating a context, there are some factory functions. And all of them return a <code>CancelFunc</code> type.
This is, as its name indicates, a function. It tells an operation to abandon its work. It's async, and
it can be called by multiple goroutines simultaneously. After the first call, the subsequent calls are
no-ops.</p>
<p>As an example, for the <code>cancelCtx</code>, <code>cancel</code> method exists. It closes the <code>done</code> channel and cancels
all of its children, plus some other cleaning tasks.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>This is an extension of the original example provided in the std library.
It depicts the usage of context within several goroutines that form a tree.</p>
<p>Once the main goroutine triggers the <code>cancel</code> function, all the others
are also cancelled.</p>
<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	// gen generates integers in a separate goroutine and
	// sends them to the returned channel.
	// The callers of gen need to cancel the context once
	// they are done consuming generated integers not to leak
	// the internal goroutine started by gen.
	gen := func(ctx context.Context) &lt;-chan int {
		ctx2, cancel := context.WithCancel(ctx)
		defer cancel()
		// propagating the cancel context to a new goroutine
		go doStuff(ctx2)
		dst := make(chan int)
		n := 1
		go func() {
			for {
				select {
				case &lt;-ctx.Done():
					fmt.Println(&quot;Closing gen&quot;)
					fmt.Println(n)
					return // returning not to leak the goroutine
				case dst &lt;- n:
					n++
				}
			}
		}()
		return dst
	}

	ctx, cancel := context.WithCancel(context.Background())
	//	defer cancel() // cancel when we are finished consuming integers
	for n := range gen(ctx) {
		fmt.Println(n)
		if n == 5 {
			break
		}
	}
	cancel()
	for {
		time.Sleep(3 * time.Second)
		break
	}
}
func doStuff(ctx context.Context) {
	fmt.Println(&quot;Starting child&quot;)
	for {
		select {
		case &lt;-ctx.Done():
			fmt.Println(&quot;Closing child&quot;)
			return
		}
	}
}

</code></pre>
<p>A plausible output (it's non-deterministic):</p>
<pre><code>1
2
3
4
5
Closing gen
6
Starting child
Closing child
</code></pre>
<h3 id="using-withtimeout"><a class="header" href="#using-withtimeout">Using WithTimeout</a></h3>
<p>This example is rather simple. But it shows how to propagate a timeout into a tree.
Here we show how the main goroutine receives a <code>Done</code> signal after 50 miliseconds. This
triggers (through <code>cancel</code>) subsequent <code>Done</code> signals to all the goroutines that
where created with the <code>WithTimeout</code> method.</p>
<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	// Pass a context with a timeout to tell a blocking function that it
	// should abandon its work after the timeout elapses.
	ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)
	ctx2, cancel2 := context.WithTimeout(context.Background(), 50*time.Millisecond)

	func(ctx2 context.Context) {
		select {
		case &lt;-ctx2.Done():
			fmt.Println(ctx2.Err()) // prints &quot;context deadline exceeded&quot;
			return
		case &lt;-time.After(100 * time.Millisecond):
			fmt.Println(&quot;overslept 2&quot;)
		}

	}(ctx2)

	defer cancel()
	defer cancel2()

	select {
	case &lt;-time.After(100 * time.Millisecond):
		fmt.Println(&quot;overslept&quot;)
	case &lt;-ctx.Done():
		fmt.Println(ctx.Err()) // prints &quot;context deadline exceeded&quot;
	}

}
</code></pre>
<h2 id="context-being-used-in-the-real-world"><a class="header" href="#context-being-used-in-the-real-world">Context being used in the real world</a></h2>
<p>These are some libraries making heavy use of this pattern:</p>
<ol>
<li><a href="https://github.com/kubernetes/kubernetes">kubernetes</a></li>
<li><a href="https://github.com/grpc/grpc-go">gRPC</a></li>
<li><a href="https://github.com/dgraph-io/dgraph">dgraph</a></li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<p>Error handling is a very important topic in software engineering. There are
plenty different schools of thought. Go's approach to it is very simple.
It treates <a href="https://blog.golang.org/errors-are-values"><strong>errors as values</strong></a>,
and to some people unsufficient. But we won't get into this discussion here.</p>
<p>The <code>error</code> type is used to indicate an <em>abnormal state</em>. When this happens,
there are several ways to act. In this chapter, we will only focus on the
availability of tools that Go provides the developer to characterize and respond
to these <em>anomalies</em>.</p>
<p><code>error</code> is defined in the <code>built-in</code> package as:</p>
<pre><code class="language-go">type error interface {
    Error() string
}
</code></pre>
<p>However, this package provides nothing else than this interface. Most of the
surrounding infrastructure is provided within the <code>errors</code> package instead.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="as"><a class="header" href="#as">As</a></h2>
<p><code>As</code> finds the <strong>first error in err's chain that matches target</strong>. If it
succeds, it sets target to that error value and returns true. Otherwise,
it returns false.</p>
<p><code>As</code> panics if target is not a non-nil pointer to either a type that implements
error, or to any interface type.</p>
<pre><code class="language-go">var e *QueryError
if errors.As(err, &amp;e) {
    // err is a *QueryError, and e is set to the error's value
}
</code></pre>
<h2 id="is"><a class="header" href="#is">Is</a></h2>
<p><code>Is</code> reports whether <strong>any error</strong> (as opposed to finding the first with <code>As</code>)
in err's chain matches target.</p>
<p>The chain consists of err itself followed by the <strong>sequence of errors obtained</strong>
<strong>by repeatedly calling Unwrap</strong>.</p>
<pre><code class="language-go">if errors.Is(err, ErrPermission) {
    // ...
}
</code></pre>
<p>This equivalent to the following:</p>
<pre><code class="language-go">if e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission {
    // ...
}
</code></pre>
<h2 id="remarks"><a class="header" href="#remarks">Remarks</a></h2>
<p>One of the biggest advantages of having these two methods, is when working with
highly nested errors. They bring all the necessary machinery to unwrap as much
as needed until a match is found. Or if there is no match, we are sure that all
the inner errors were also compared.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="unwrap"><a class="header" href="#unwrap">Unwrap</a></h2>
<p><em>(feature added in Go 1.13)</em></p>
<p>This is an interesting feature, when building errors that
<strong>contain other errors</strong>.</p>
<p><code>Unwrap</code> is actually defined as follows:</p>
<pre><code class="language-go">func Unwrap(err error) error {

	u, ok := err.(interface {
		Unwrap() error
	})
	if !ok {
		return nil
	}
	return u.Unwrap()

}
</code></pre>
<p>It first checks whether <code>err</code> has itself the <code>Unwrap</code> method. If it doesn't, then
nothing else can be done. There is nothing to unwrap. Nada. But if the method
is defined, it calls it and returns its value, which is an <code>error</code> itself.</p>
<p>This is a very useful way of composing errors, and thus adding much more
information. We could think of the following scenario:</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;errors&quot;
)
type databaseError struct {
    err error
}

type queryMissingParamsError struct {
    params string
}

func (de *databaseError) Unwrap() error {
    return de.err
}

func (de *databaseError) Error() string {
    return fmt.Sprintf(&quot;Database error. %s&quot;, de.err)
}

func (qmp *queryMissingParamsError) Error() string {
    return fmt.Sprintf(&quot;Some parameter were missing: %s&quot;, qmp.params)
}

// bogus query
type Query struct {}

func (q *Query) Check() error {
    return &amp;databaseError {
        err: &amp;queryMissingParamsError {
            params: &quot;name&quot;,
        },
    }
}

func handleDatabaseQuery(query *Query) error {
    err := query.Check()
    if err == nil {
        return nil
    }
    log.Print(err)
    return errors.Unwrap(err)
}
func main() {
	q := &amp;Query{}
	err := handleDatabaseQuery(q)
	fmt.Println(err)
}

</code></pre>
<p>In this example, we can see how an error can pack and unpack other errors. And
we can choose to define a strategy for the different scenarios. So, in this
particular example, we could ask the user to make the query again and remind
her not to forget to include <em>name</em> as a paramter.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="making-error-great-again"><a class="header" href="#making-error-great-again">Making error great again</a></h2>
<p>The following is a canonical example of how horrible error handling
can become in Go:</p>
<pre><code class="language-go">_, err = fd.Write(p0[a:b])
if err != nil {
    return err
}
_, err = fd.Write(p1[c:d])
if err != nil {
    return err
}
_, err = fd.Write(p2[e:f])
if err != nil {
    return err
}
// and so on
</code></pre>
<p>An improvement, using a helper function:</p>
<pre><code class="language-go">var err error
write := func(buf []byte) {
    if err != nil {
        return
    }
    _, err = w.Write(buf)
}
write(p0[a:b])
write(p1[c:d])
write(p2[e:f])
// and so on
if err != nil {
    return err
}
</code></pre>
<p>However, here we need to be sure that <code>err</code> is being captured by <code>write</code>
every time we call this function. We could actually do better, by creating a
new type, and adding a method for it that does what <code>write</code> is doing here. Then,
we will not need to have any closure, nor ensure that the value is being closed
by the function.</p>
<p>This is even a much better way of working with errors. And in some ways, it
brings to the table some of Haskell's/FP approach to error handling:</p>
<pre><code class="language-go">type errWriter struct {
    w   io.Writer
    err error
}

func (ew *errWriter) write(buf []byte) {
    if ew.err != nil {
        return
    }
    _, ew.err = ew.w.Write(buf)
}
</code></pre>
<pre><code class="language-go">ew := &amp;errWriter{w: fd}
ew.write(p0[a:b])
ew.write(p1[c:d])
ew.write(p2[e:f])
// and so on
if ew.err != nil {
    return ew.err
}
</code></pre>
<p>Here, <code>write</code> checks whether <code>errWriter</code> have failed before. If it
did, then it won't do anything again; we are an <em>abnormal state</em> already.
Otherwise, it's free to do some work.</p>
<h3 id="references"><a class="header" href="#references">References:</a></h3>
<ul>
<li>https://blog.golang.org/errors-are-values</li>
<li>http://jxck.hatenablog.com/entry/golang-error-handling-lesson-by-rob-pike</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="sync"><a class="header" href="#sync">Sync</a></h1>
<p>When working on a concurrent setup, Go's capabilities shine. It exposes natively
channels and goroutines. It makes it really easy to get off the ground with a
program that can -in many cases- run much faster.</p>
<p>The hard part of concurrency stems from having moving parts, which need
to communicate with each other and where <strong>sequence</strong> of that exchange really
matters. There are times wehere channels fall short. And that's why resorting
to the <code>sync</code> package can be a really good option.</p>
<p>Normally, I only pick a selection of functions, types, methods and interfaces to
cover from each package. But <code>sync</code>is an exception. I will cover everything from
it, because I really believe it's a critical package. And mastering makes a
difference.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="cond"><a class="header" href="#cond">Cond</a></h2>
<blockquote>
<p>Cond implements a condition variable, a rendezvous point for goroutines
waiting for or announcing the occurrence of an event. </p>
</blockquote>
<h2 id="broadcast"><a class="header" href="#broadcast">Broadcast</a></h2>
<p>A typical use case for <code>Broacast</code> is when multiple goroutines are waiting
for something to happen. In order to let all of them that a certain event
happened using channels, then we would need to have one channel for each
of them. And then send each of them a message. This is what <code>Broadcast</code>
is about. Broadcast wakes all goroutines waiting on that <code>Cond</code>so that
they can continue working.</p>
<p>Inside a <code>Cond</code> type, there is an attribute called <code>notify</code> of type <code>notifyList</code>.
<code>notify</code> is used by a function called <code>runtime_notifyListNotifyAll</code> in order to wake
up all goroutines.</p>
<p>func (c *Cond) Broadcast() {
c.checker.check()
runtime_notifyListNotifyAll(&amp;c.notify)
}</p>
<p>And even when it's not necessary to understand how <code>Broadcast</code>works, if we peek
at runtime_notifyListNotifyAll implementation, we can actually verify that it
<em>readies</em> all the outstanding goroutines by calling <code>goready</code>.</p>
<pre><code class="language-go">
// notifyListNotifyAll notifies all entries in the list.

//go:linkname notifyListNotifyAll sync.runtime_notifyListNotifyAll

func notifyListNotifyAll(l *notifyList) {
	// Fast-path: if there are no new waiters since the last notification
	// we don't need to acquire the lock.
	if atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) {
		return
	}
    /* 
    ommited code
    */
    s := l.head
    /* 
    ommited code
    */
	for s != nil {
		next := s.next
		s.next = nil
		readyWithTime(s, 4) // this function calls goready
		s = next
	}
}
</code></pre>
<h2 id="signal"><a class="header" href="#signal">Signal</a></h2>
<p>Signal will only wake <strong>one</strong> goroutine, if there was at least one waiting.</p>
<p>The implementation is similar to the one for <code>Broadcast</code>. This time, it relies
on a helper function called <code>notifyListNotifyOne</code>.</p>
<h2 id="wait"><a class="header" href="#wait">Wait</a></h2>
<p>Cond has an associated <code>Locker</code> (which normally is a *Mutex or *RWMutex). This
<code>Locker</code> must be held when calling the Wait method.</p>
<p>If there's a goroutine that needs to be awaken to do some work,
it can be modelled as follow:</p>
<pre><code class="language-go">go func(c *sync.Cond) {
    // hold the Locker when calling the wait method
    c.L.Lock()
    for !condition() {
        c.Wait()
    }
    // ... make use of condition ...
    c.L.Unlock()
    // Unlock the Locker when its done
}
</code></pre>
<p>For completeness, a <code>Locker</code> is just an interface that defines two methods: <code>Lock</code> and <code>Unlock</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="mutex"><a class="header" href="#mutex">Mutex</a></h2>
<p>A <code>Mutex</code> is a flag that can be held by at most one goroutine at at time. Its
name is derived from <em>mutually exclusive</em>, which indicates its purpose. The
<em>raison detre</em> of a <code>Mutex</code> is synchronization, by preventing that no other
goroutine can perform an operation over the resources that are being mutexed.</p>
<p>It fulfills the <code>Locker</code> interface, thus it defines <code>Lock</code> and <code>Unlock</code>.</p>
<p>It's important to note that a lock doesn't belong to a particular goroutine.
Thus, it's allowed for a goroutine to lock the <code>Mutex</code> and another to <code>Unlock</code>
it. Therefore, it's still important how the different goroutines interact with
the resource in order both to avoid deadlocks but also to avoid accessing to
a resource when it's not locked.</p>
<h2 id="lock"><a class="header" href="#lock">Lock</a></h2>
<p>This is how <code>Lock</code> is implemented. But the real meat lies in <code>lockSlow</code>, which
we won't cover here. I'm mostly copying the definition just to see how the pieces
are put together. The complete implementation is quite complicated, and it involves
assembly code in the very end.</p>
<pre><code class="language-go">func (m *Mutex) Lock() {
	// Fast path: grab unlocked mutex.
	if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
		if race.Enabled {
			race.Acquire(unsafe.Pointer(m))
		}
		return
	}
	m.lockSlow()
}
</code></pre>
<p>If the <code>Mutex</code> is already locked, then the goroutine that calls <code>Lock</code> will block
until the <code>Mutex</code> gets released, and can be locked by it. </p>
<h2 id="unlock"><a class="header" href="#unlock">Unlock</a></h2>
<p>This method is responsible for unlocking the <code>Mutex</code>. It can be called from any
goroutine, and it's not necessary that is the one that locked it. However, if
it's unlocked, it cannot be unlocked right away. Otherwise, it panics. 
The implementation of this behavior is as follows:</p>
<pre><code class="language-go">const (
    mutexLocked = 1 &lt;&lt; iota // mutex is locked
)

func (m *Mutex) unlockSlow(new int32) {
	if (new+mutexLocked)&amp;mutexLocked == 0 {
		throw(&quot;sync: unlock of unlocked mutex&quot;)
    }
    /*
    ...
    */
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="once---do"><a class="header" href="#once---do">Once - Do</a></h2>
<p>A very simple - but sometimes useful - method is <code>Do</code>. Its role is simply to
guarantee that a function run through it won't run more than once. This means
that if we have:</p>
<pre><code class="language-go">var once sync.Once
a := make([]int, 0)
once.Do(func() {a = append(a, 1)})
once.Do(func() {a = append(a, 2)})
fmt.Print(a) // [1] and not [1 2]
</code></pre>
<p><code>Once</code> is the right type, when it's important that a certain resource gets
called or initialized only once. In order to be able to call it again, and
that the function is actually run, another instance of <code>Once</code> needs to be
defined. And <code>Do</code> called from that new instance.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="pool"><a class="header" href="#pool">Pool</a></h2>
<blockquote>
<p>A Pool is a set of temporary objects that may be individually saved and retrieved.</p>
</blockquote>
<p><code>Pool</code> provides a way to amortize allocation overhead. It serves for when there
are multiple users of a resource, and we would like to avoid having to create
a new time every time we need to.</p>
<p><code>Pool</code> caches allocated but unused items so that they can be available for later
use. It releives pressure from the garbage collector. However, 
<strong>Any item stored in the Pool may be removed automatically at</strong>
<strong>any time without notification</strong>.</p>
<pre><code class="language-go">type Pool struct {

    // New optionally specifies a function to generate
    // a value when Get would otherwise return nil.
    // It may not be changed concurrently with calls to Get.
    New func() interface{}
    // contains filtered or unexported fields
}
</code></pre>
<p>The important bit from the definition is that, whenever we call
<code>Get</code>, and there are no items left in the pool, then it creates
a new one by calling <code>New</code>. </p>
<p>Once an item has been used, it can be returned to the <code>Pool</code> by
calling <code>Put</code>. <code>Put</code> adds an item back into the <code>Pool</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="waitgroup"><a class="header" href="#waitgroup">WaitGroup</a></h2>
<blockquote>
<p>A WaitGroup waits for a collection of goroutines to finish.
The main goroutine calls <code>Add</code> to set the number of goroutines to wait for.
Then each of the goroutines runs and calls <code>Done</code> when finished.
At the same time, <code>Wait</code> can be used to block until all goroutines have finished. </p>
</blockquote>
<p>It's possible to have another goroutine also to wait on this group. The only
real constraint is that <code>Add</code> can only be called by the main one.</p>
<h3 id="add"><a class="header" href="#add">Add</a></h3>
<pre><code class="language-go">func (wg *WaitGroup) Add(delta int)
</code></pre>
<p>The <strong>delta</strong> defines how many more - or less - goroutines, the goroutines
waiting need to actually wait for. When the counter gets to zero, then
all the waiting goroutines get released. If the counter is negative, then
<code>Add</code> panics.</p>
<h3 id="done"><a class="header" href="#done">Done</a></h3>
<p>It decrements the counter by one.</p>
<h3 id="wait-1"><a class="header" href="#wait-1">Wait</a></h3>
<p>Blocks the goroutine until the counter of the <code>WaitGroup</code> gets to zero.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="io"><a class="header" href="#io">IO</a></h2>
<blockquote>
<p>Package io provides basic interfaces to I/O primitives.
Its primary job is to wrap existing implementations of such primitives,
such as those in package os, into shared public interfaces that abstract
the functionality, plus some other related primitives.</p>
</blockquote>
<p><code>io</code> is a very important package in Go. It provides a set of primitives
and interfaces that every developer needs to understand in order to work
properly with bytes, standard input, output, error and pipes among others.</p>
<p>An important note is that these primitives are not thread safe by default.
This means that they shouldn't be used by multiple goroutines at the same time.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="writer"><a class="header" href="#writer">Writer</a></h2>
<p>Writer is the interface that wraps the basic Write method. <code>io</code> package makes
extensive use of this interface. <code>Writer</code> is implemented by <code>os.File</code>. Which
in the <code>io</code> package is used to reference to <code>Stdin</code>, <code>StdOut</code>, and <code>StdErr</code>:</p>
<pre><code class="language-go">var (
    Stdin  = NewFile(uintptr(syscall.Stdin), &quot;/dev/stdin&quot;)
    Stdout = NewFile(uintptr(syscall.Stdout), &quot;/dev/stdout&quot;)
    Stderr = NewFile(uintptr(syscall.Stderr), &quot;/dev/stderr&quot;)
)
</code></pre>
<h3 id="how-does-writer-works"><a class="header" href="#how-does-writer-works">How does writer works?</a></h3>
<blockquote>
<p>Write writes len(p) bytes from p to the underlying data stream.
It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))
and any error encountered that caused <code>write</code> function to stop
early. Write must return a non-nil error if it returns n &lt; len(p).
<code>Write</code> must not modify the slice data, even temporarily.</p>
</blockquote>
<p>Implementations must not retain p.</p>
<pre><code class="language-go">type Writer interface {
    Write(p []byte) (n int, err error)
}
</code></pre>
<p>To see an implementation, we can check the one for <code>os.File</code>. There
are some OS dependent helper functions that help <code>Write</code> doing their
job. But essentailly it is a transparent copy of its description.</p>
<p>Check a fragment of the POSIX implementatiof of <code>Write</code> from the source
code in the <code>os</code> package:</p>
<pre><code class="language-go">// Write writes len(b) bytes to the File.
// It returns the number of bytes written and an error, if any.
// Write returns a non-nil error when n != len(b).

func (f *File) Write(b []byte) (n int, err error) {
    // for posix f.checkValid returns nil unless f is nil
	if err := f.checkValid(&quot;write&quot;); err != nil {
		return 0, err
	}
	n, e := f.write(b)
	if n &lt; 0 {
		n = 0
	}
	if n != len(b) {
		err = io.ErrShortWrite
	}
	epipecheck(f, e)

if e != nil {
		err = f.wrapErr(&quot;write&quot;, e)
	}
	return n, err
}
</code></pre>
<p>Side note: it's important to see that <code>write</code> will block the thread. There's
an ongoing <a href="https://github.com/golang/go/issues/6817">discussion</a> to provide
an async API for files, but it's still being considered.</p>
<h2 id="reader"><a class="header" href="#reader">Reader</a></h2>
<p>Similarly, <code>Reader</code> is the reading counterpart. It is also an interface that wraps
the <code>Read</code> method.</p>
<blockquote>
<p><code>Read</code> reads up to len(p) bytes into p. It returns the number of bytes
read (0 &lt;= n &lt;= len(p)) and any error encountered. Even if <code>Read</code> returns
n &lt; len(p), it may use all of p as scratch space during the call.
If some data is available but not len(p) bytes, <code>Read</code> conventionally
returns what is available instead of waiting for more.</p>
</blockquote>
<p>It is defined as:</p>
<pre><code class="language-go">type Reader interface {
    Read(p []byte) (n int, err error)
}
</code></pre>
<p>As an implementor of <code>Read</code>, when there is nothing else to read, the Standard
Library suggest to return 0, <code>EOF</code> instead. 0, nil is only acceptable when
<code>p</code> length is equal to zero. But that's not happening very often.</p>
<p>Additionally, the Standard Library suggest first reading the <code>n</code> bytes, and then
handling the error if there was any. It adds that:</p>
<blockquote>
<p>Doing so correctly handles I/O errors that happen after reading some bytes and
also both of the allowed EOF behaviors.</p>
</blockquote>
<p><code>Read</code> implementation for type <code>os.File</code> relies on a helper function <code>read</code> that
does all the work (except error handling). <code>read</code> itself relies on <code>poll.FD</code> (on *nix),
which is in charge of checking whether there is anything to be read on that
file descriptor. For the very curious reader, go and check its implemenation of
<code>FD</code>'s <code>Read</code> <a href="https://golang.org/src/internal/poll/fd_unix.go?s=4169:4210#L135">here</a>.</p>
<pre><code class="language-go">func (f *File) Read(b []byte) (n int, err error) {
	if err := f.checkValid(&quot;read&quot;); err != nil {
		return 0, err
	}

	n, e := f.read(b)
	return n, f.wrapErr(&quot;read&quot;, e)
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="pipe"><a class="header" href="#pipe">Pipe</a></h1>
<p>In Go a pipe is <strong>synchronous in-memory pipe</strong>. <code>pipe</code> is a type that
is not publicly exposed. However, <code>io</code> allows us to interact with
it through <code>PipeWriter</code> and <code>PipeReader</code>. In order to create
these two halves of the <code>pipe</code>, <code>io</code> has a function:</p>
<pre><code class="language-go">func Pipe() (*PipeReader, *PipeWriter)
</code></pre>
<p>Just for having the full picture, and to see how it works under the hood, this
is how <code>pipe</code> is defined:</p>
<pre><code class="language-go">// A pipe is the shared pipe structure underlying PipeReader and PipeWriter.
type pipe struct {
	wrMu sync.Mutex // Serializes Write operations
	wrCh chan []byte
	rdCh chan int
	once sync.Once // Protects closing done
	done chan struct{}
	rerr onceError
	werr onceError
}
</code></pre>
<p>Again, as consumers of <code>pipe</code> we only care about <code>PipeReader</code> and <code>PipeWriter</code>.</p>
<blockquote>
<p>It can be used to connect code expecting an <code>io.Reader</code> with code expecting
an <code>io.Writer</code>.</p>
</blockquote>
<p>Sometimes it can happen that we hold an <code>io.Reader</code>, but we need to call a function
that expects an <code>io.Writer</code>. <code>Pipe</code> is a really good tool for acheiving it.</p>
<blockquote>
<p>The data is copied directly from the <code>io.Write</code> to the corresponding <code>io.Read</code>
(or Reads) there is no internal buffering.</p>
</blockquote>
<h2 id="video-about-pipes"><a class="header" href="#video-about-pipes">Video about pipes</a></h2>
<p>I really suggest anyone to visit <a href="https://www.youtube.com/watch?v=LHZ2CAZE6Gs">this video</a>
to get a deeper understanding on
how to use pipes.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
